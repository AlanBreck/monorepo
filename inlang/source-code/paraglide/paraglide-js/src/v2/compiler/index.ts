import { lookup, type ProjectSettings } from "@inlang/sdk"
import type {
	MessageBundle,
	Message,
	InputDeclaration,
	Declaration,
	Pattern,
	Expression,
	Variant,
} from "@inlang/sdk/v2"
import { createRuntime } from "./runtime/index.js"
import { registry } from "./registry/registry.js"
import REGISTRY_JS_FILE from "./registry/registry.js.template?raw"
import { getInputTypeConstraints } from "./types.js"
import { generateJSDoc } from "./codegen.js"

export type CompileOptions = {
	messageBundles: Readonly<MessageBundle[]>
	settings: ProjectSettings
}

const IGNORE_FILE = `# ignore everything because the directory is auto-generated by inlang paraglide-js
# for more info visit https://inlang.com/m/gerre34r/paraglide-js
*
`

export function compileBundle({
	messageBundles,
	settings,
}: CompileOptions): Record<string, string> {
	const fallbackLanguages = getFallbackMap(settings.languageTags, settings.sourceLanguageTag)

	const compiledBundles = messageBundles.map((bundle) => {
		const messages = bundle.messages.map((message) =>
			compileMessage({ message, bundleId: bundle.id })
		)

		// loop over the inputs of each message & merge them
		// if two messaegs have the same input but with different types throw an error
		const inputNames = new Set<string>(messages.flatMap((m) => Object.keys(m.inputs)))

		const inputs = Object.fromEntries(
			[...inputNames].map((name) => {
				const typeConstraints = new Set<string>()
				for (const message of messages) {
					const inputTypeConstraints = message.inputs[name]
					if (!inputTypeConstraints) continue
					for (const type of inputTypeConstraints) typeConstraints.add(type)
				}

				//this condition should never trigger - Just for typesafety
				if (typeConstraints.size === 0)
					throw new Error(`A parameter must have a type in at least one language`)
				return [name, typeConstraints]
			})
		)

		return {
			id: bundle.id,
			messages,
			inputs,
		}
	})

	const files: Record<string, string> = {
		".prettierignore": IGNORE_FILE,
		".gitignore": IGNORE_FILE,
	}

	// create a file for each language
	for (const locale of settings.languageTags) {
		const filename = `messages/${locale}.js`

		files[filename] = [
			"/* eslint-ignore */",
			"import * as registry from '../registry.js'",
			...compiledBundles.map((bundle) => {
				const message = bundle.messages.find((message) => message.locale === locale)
				if (message) return message.source

				const fallbackLanguage = fallbackLanguages[locale]
				if (!fallbackLanguage) return `export const ${bundle.id} = () => "${bundle.id}"`
				else return `export { ${bundle.id} } from './${fallbackLanguage}.js'`
			}),

			// aliases
			...messageBundles
				.filter((bundle) => bundle.alias["default"] !== undefined)
				.map((bundle) => {
					const alias = bundle.alias["default"] as string
					return `export { ${bundle.id} as ${alias} }`
				}),
		].join("\n")
	}

	//generate an index file for all messages
	files["messages.js"] = [
		"import { languageTag } from './runtime.js'",
		...settings.languageTags.map(
			(locale) => `import * as ${locale} from './messages/${locale}.js'`
		),
		"",
		...compiledBundles.map((bundle) => {
			const hasInputs = Object.keys(bundle.inputs).length !== 0

			return `export ${bundle.id} = (${hasInputs ? "inputs" : ""}, options) => {
    return {
${settings.languageTags.map((lang) => `\t\t"${lang}": ${lang}.${bundle.id}`).join(",\n")}
	}[options.languageTag || languageTag()](${hasInputs ? "inputs" : ""})
}`
		}),
	].join("\n")

	files["runtime.js"] = createRuntime(settings)
	files["registry.js"] = REGISTRY_JS_FILE

	return files
}

type CompiledMessage = {
	/**
	 * The language of the message
	 */
	locale: string

	/**
	 * The input-types of the message
	 */
	inputs: Record<string, Set<string>>

	/**
	 * The source-code for the message function
	 */
	source: string
}

export function compileMessage({
	message,
	bundleId,
}: {
	message: Message
	bundleId: string
}): CompiledMessage {
	const inputDeclarations = message.declarations.filter(isInputDeclaration)

	const inputsWithAnnotation = inputDeclarations.filter(
		(input) => input.value.annotation !== undefined
	)

	//Make sure that all declarations are input declarations
	if (inputDeclarations.length !== message.declarations.length) {
		throw new Error("Only input declarations are supported for now")
	}

	const inputs = getInputTypeConstraints(message, registry)

	const hasInputs = Boolean(inputDeclarations.length)
	const hasSelectors = Boolean(message.selectors.length)

	const jsdoc: string[] = hasInputs
		? [
				generateJSDoc({
					params: {
						inputs: {
							type: `{\n${Object.entries(inputs)
								.map(([name, constraints]) => {
									const type = constraints.size
										? [...constraints].join(" & ")
										: "NonNullable<unknown>"
									return `${name}: ${type}`
								})
								.join(",\n")}\n}`,
						},
					},
					returns: { type: "string", description: "The stringified message" },
				}),
		  ]
		: []

	if (!hasSelectors) {
		const variant = message.variants[0]
		if (!variant) throw new Error(`A message must have at least one variant`)
		if (variant.match.length !== 0)
			throw new Error(`A variant on a message with no selectors must not have a match`)

		const source = inputsWithAnnotation.length
			? `${jsdoc}\nexport const ${bundleId} = (inputs) => {
${inputsWithAnnotation
	.map((input) => {
		return `    inputs.${input.name} = ${compileExpression(input.value)}`
	})
	.join("\n")}
    return ${compilePattern(variant.pattern)}
}`
			: `${jsdoc}\nexport const ${bundleId} = (${hasInputs ? "inputs" : ""}) => ${compilePattern(
					variant.pattern
			  )}`

		return {
			source,
			inputs,
			locale: message.locale,
		}
	}

	{
		//enforce that the variants are valid
		let hasCatchall = false
		for (const variant of message.variants) {
			if (variant.match.length !== message.selectors.length)
				throw new Error(
					`Variant has ${variant.match.length} selectors, but message has ${message.selectors.length} selectors`
				)

			hasCatchall ||= variant.match.every((match) => match === "*")
		}
		if (!hasCatchall) throw new Error("Message must have a catch-all variant")
	}

	const variants = [...message.variants].sort(compareVariants)

	const lines: string[] = [
		...jsdoc,
		`export const ${bundleId} = (${hasInputs ? "inputs" : ""}) => {`,

		...inputsWithAnnotation.map((input) => {
			return `    input.${input.name} = ${compileExpression(input.value)}`
		}),

		...message.selectors.map((selector, idx) => {
			return `	const selector_${idx} = ${compileExpression(selector)}`
		}),
		"",

		...variants.map((variant) => {
			//serialize a condition
			const condition =
				variant.match
					.map((match, idx) => (match === "*" ? "true" : `selector_${idx} === "${match}"`))
					.filter((cond) => cond !== "true") //remove catchalls
					.join(" && ") || "true" //fallback to just true if all selectors are catchalls

			//only add an if-statemetn if the condition isn't guaranteed to be true
			return condition === "true"
				? `\treturn ${compilePattern(variant.pattern)}`
				: `\tif(${condition}) return ${compilePattern(variant.pattern)}`
		}),
		"}",
	]

	const source = lines.join("\n")

	return {
		source,
		inputs: inputs,
		locale: message.locale,
	}
}

/**
 * Returns a template string for the given pattern
 * @param pattern
 */
function compilePattern(pattern: Pattern): string {
	return (
		"`" +
		pattern
			.map((el) => {
				switch (el.type) {
					case "text":
						return el.value
					case "expression": {
						return "${" + compileExpression(el) + "}"
					}
				}
			})
			.join("") +
		"`"
	)
}

function compileExpression(expression: Expression): string {
	const arg =
		expression.arg.type === "variable"
			? "inputs." + expression.arg.name
			: expression.arg.type === "literal"
			? '"' + expression.arg.value + '"'
			: "undefined" //should never match but just in case

	if (!expression.annotation) {
		return arg
	}

	const func = registry[expression.annotation.name]
	if (!func) throw new Error("Unknown function: " + expression.annotation.name)

	const hasOptions = expression.annotation.options.length > 0

	if (!hasOptions) return `registry.${expression.annotation.name}(${arg})`

	const expectedOptions = Object.keys(func.signature.options)
	for (const option of expression.annotation.options) {
		if (!expectedOptions.includes(option.name)) throw new Error("Unknown option: " + option)
	}

	const options = `{ ${expression.annotation.options
		.map((opt) => {
			const value =
				opt.value.type === "literal" ? '"' + opt.value.value + '"' : "inputs." + opt.value.name
			return `"${opt.name}" : ${value}`
		})
		.join(",\n")} }`

	return `registry.${expression.annotation.name}(${arg}, ${options})`
}

function isInputDeclaration(declaration: Declaration): declaration is InputDeclaration {
	return declaration.type === "input"
}

function compareVariants(variantA: Variant, variantB: Variant): -1 | 0 | 1 {
	for (let i = 0; i < variantA.match.length; i++) {
		const matchA = variantA.match[i]
		const matchB = variantB.match[i]

		if (matchA === "*" && matchB !== "*") return 1
		if (matchB === "*" && matchA !== "*") return -1
	}

	return 0
}

function getFallbackMap(languageTags: string[], sourceLanguageTag: string) {
	return Object.fromEntries(
		languageTags.map((lang) => {
			const fallbackLanguage = lookup(lang, {
				languageTags: languageTags.filter((t) => t !== lang),
				defaultLanguageTag: sourceLanguageTag,
			})

			if (lang === fallbackLanguage) return [lang, undefined]
			else return [lang, fallbackLanguage]
		})
	)
}
